- id: battery_open
  desc: ""
  code:
  - mocdp.comp.dpconnect
  - name2dp: 
      times: energy_times
      battery: battery
      actuation:
      - mocdp.comp.SimpleWrap
      - fnames: weight
        rnames: actuation_power
        dp: ['mocdp.example_battery.Mobility', {}]
    connections:
    - 'times.power >= actuation.actuation_power'
    - 'battery.capacity >= times.energy'


- id: battery_complete
  desc: ""
  code:
  - mocdp.comp.dpgraph
  - name2dp: 
      times: energy_times
      battery: battery
      actuation:
      - mocdp.comp.SimpleWrap
      - fnames: weight
        rnames: actuation_power
        dp: ['mocdp.example_battery.Mobility', {}]
    connections:
    - 'times.power >= actuation.actuation_power'
    - 'battery.capacity >= times.energy'
    - 'actuation.weight >= battery.battery_weight'
    split: []

- id: energy_times
  desc: ""
  code:
  - mocdp.comp.SimpleWrap
  - fnames: ['mission_time', 'power']
    rnames: 'energy'
    dp: energy_product

- id: battery
  desc: ""
  code:
  - mocdp.comp.SimpleWrap
  - fnames: 'capacity'
    rnames: 'battery_weight'
    dp: BatteryDP

- id: maxh
  desc: ""
  code:
  - mocdp.comp.dpgraph
  - name2dp: 
      max: max_f_r
      h: hnlin
    connections:
    - 'h.x >= max.z'
    - 'max.r >= h.r'
    split: []

- id: max_f_r
  desc: ""
  code:
  - mocdp.comp.SimpleWrap
  - fnames: ['f', 'r']
    rnames: 'z'
    dp: 
    - mocdp.dp.Max
    - F: Rcomp_J

- id: hnlin
  desc: ""
  code:
  - mocdp.comp.SimpleWrap
  - fnames: 'x'
    rnames: 'r'
    dp: SimpleNonlinearity1

- id: minh
  desc: ""
  code:
  - mocdp.comp.dpgraph
  - name2dp: 
      min: min_f_r
      h: hnlin
    connections:
    - 'h.x >= min.z'
    - 'min.r >= h.r'
    split: []

- id: min_f_r
  desc: ""
  code:
  - mocdp.comp.SimpleWrap
  - fnames: ['f', 'r']
    rnames: 'z'
    dp: 
    - mocdp.dp.Min
    - F: Rcomp_J

- id: mobility
  desc: ""
  code:
  - mocdp.comp.SimpleWrap
  - fnames: weight
    rnames: actuation_power
    dp: ['mocdp.example_battery.Mobility', {}]

- id: battery_complete_parsed
  desc: ""
  code: 
  - mocdp.lang.parse_ndp
  - string: |
      cdp {
          #
          provides x [s]                                                                      
          #
          battery = load battery
          times = load energy_times
          actuation = load mobility
          #
          times.mission_time >= x
          #     
          times.power >= actuation.actuation_power
          battery.capacity >= times.energy
          actuation.weight >= battery.battery_weight
      }


- id: testmax
  desc: "Test with max"
  code: 
  - mocdp.lang.parse_ndp
  - string: |
      cdp {
          provides f [R]
          
          hnlin = dp {
              provides x [R]
              requires r [R]
              
              implemented-by load SimpleNonlinearity1
          }
          
          hnlin.x >= max(f, hnlin.r)        
      }

- id: testmin
  desc: "Test with min"
  code: 
  - mocdp.lang.parse_ndp
  - string: |
      cdp {
          provides f [R]
          
          hnlin = dp {
              provides x [R]
              requires r [R]
              
              implemented-by load SimpleNonlinearity1
          }
          
          hnlin.x >= min(f, hnlin.r)        
      }

- id: testminsq
  desc: "Test with min"
  code: 
  - mocdp.lang.parse_ndp
  - string: |
      cdp {
        provides f0 [R]
        DP = cdp {
            provides f [R]
            requires r2 [R]
            
            hnlin = dp {
                provides x [R]
                requires r [R]
               
                implemented-by load SimpleNonlinearity1
            }
            
            hnlin.x >= min(f, hnlin.r)        
            r2 >= hnlin.r
        }
        DP.f >= max(f0, DP.r2)
      }

- id: testminsq_2
  desc: "Equivalent, just switching the order of arguments to max"
  code: 
  - mocdp.lang.parse_ndp
  - string: |
      cdp {
        provides f0 [R]
        DP = cdp {
            provides f [R]
            requires r2 [R]
            
            hnlin = dp {
                provides x [R]
                requires r [R]
                
                implemented-by load SimpleNonlinearity1
            }
            
            hnlin.x >= min(f, hnlin.r)  
            r2 >= hnlin.r      
        }
        DP.f >= max(DP.r2, f0)
      }


- id: testminsq_3
  desc: "Equivalent, just switching the order of arguments to max"
  code: 
  - mocdp.lang.parse_ndp
  - string: |
      cdp {
        provides f0 [R]
        DP = cdp {
            provides f [R]
            requires r2 [R]
            
            hnlin = dp {
                provides x [R]
                requires r [R]
                
                implemented-by load SimpleNonlinearity1
            }
            
            hnlin.x >= min(hnlin.r, f)        
            r2 >= hnlin.r
        }
        DP.f >= max(DP.r2, f0)
      }

- id: testlang13_diagram
  desc: "Diagram in the presentation"
  code: 
  - mocdp.lang.parse_ndp
  - string: |
      cdp {
          provides cargo [g]
          requires total_weight [g]
          #
          battery = dp {
              provides capacity [J]
              requires battery_weight [g]
              
              implemented-by load BatteryDP
          }
          #
          actuation = dp {
              provides weight [g]
              requires actuation_power [W]
              
              implemented-by code mocdp.example_battery.Mobility
          }
          #
          sensing = dp {
          #
              requires sensing_power [W]
              requires mission_time [s]
          #    
              implemented-by code mocdp.example_battery.PowerTimeTradeoff
          }
          #
          (capacity provided by battery) >= sensing.mission_time  * (actuation.actuation_power + sensing.sensing_power)
          cargo + (battery_weight required by battery) <= weight provided by actuation
          #
          total_weight >= cargo + (battery_weight required by battery)
      }
